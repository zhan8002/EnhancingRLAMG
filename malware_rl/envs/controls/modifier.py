import array
import json
import os
import random
import numpy as np
import subprocess
import sys
import tempfile
from os import listdir
from os.path import isfile, join
import pefile
import lief
import string
import re

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = (
    open(
        os.path.join(
            module_path,
            "section_names.txt",
        ),
    )
    .read()
    .rstrip()
    .split("\n")
)
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, "small_dll_imports.json")),
)

ALL_SECTION_NAMES = (
    open(
        os.path.join(
            module_path,
            "all_section_names.txt",
        ),
    )
    .read()
    .rstrip()
    .split("\n")
)




class ModifyBinary:
    def __init__(self, bytez):
        self.bytez = bytez
        self.trusted_path = module_path + "/trusted_dpgan/"

        self.benign_path = module_path + "/trusted_benign/"

    def randomly_select_trusted_file(self):
        return random.choice(
            [
                join(self.trusted_path, f)
                for f in listdir(self.trusted_path)
                if (f != ".gitkeep") and (isfile(join(self.trusted_path, f)))
            ],
        )

    def randomly_select_benign_file(self):
        return random.choice(
            [
                join(self.benign_path, f)
                for f in listdir(self.benign_path)
                if (f != ".gitkeep") and (isfile(join(self.benign_path, f)))
            ],
        )

    def extract_payload(self):
        random_dpgan_file = self.randomly_select_trusted_file()

        with open(random_dpgan_file, "r") as f:
            data = f.readline()
            payload = np.array(data.split(), dtype=int)




        ## random content
        # random_payload = bytearray([0] * 2**10)
        # for j in range(len(random_payload)):
        #     payload[j] = random.choice([i for i in range(256)])
        

        ## benign content
        # flag = False
        #
        # while flag == False:
        #     random_benign_file = self.randomly_select_benign_file()
        #     pe = pefile.PE(random_benign_file)
        #     for section in pe.sections:
        #         if b'text' == section.Name[1:5]:
        #             flag = True
        #
        #
        # benign_binary = lief.PE.parse(random_benign_file)
        # benign_binary_section_content = benign_binary.get_section(
        #     ".text",
        # ).content
        #
        # payload = bytearray(benign_binary_section_content)

        return payload


    def _search_cave(
        self,
        name,
        body,
        file_offset,
        vaddr,
        cave_size=128,
        _bytes=b"\x00",
    ):
        found_caves = []
        null_count = 0
        size = len(body)

        for offset in range(size):
            byte = body[offset]
            check = False

            if byte in _bytes:
                null_count += 1
            else:
                check = True

            if offset == size - 1:
                check = True
                offset += 1

            if check:
                if null_count >= cave_size:
                    cave_start = file_offset + offset - null_count
                    cave_end = file_offset + offset
                    cave_size = null_count
                    found_caves.append([cave_start, cave_end, cave_size])
                null_count = 0
        return found_caves

    def _binary_to_bytez(self, binary, imports=False):
        # Write modified binary to disk
        builder = lief.PE.Builder(binary)
        builder.build_imports(imports)
        builder.build()

        self.bytez = array.array("B", builder.get_build()).tobytes()
        return self.bytez

    def add_bytes_to_section_cave(self):
        caves = []
        binary = lief.PE.parse(list(self.bytez))
        base_addr = binary.optional_header.imagebase
        for section in binary.sections:
            section_offset = section.pointerto_raw_data
            vaddr = section.virtual_address + base_addr
            body = section.content

            if section.sizeof_raw_data > section.virtual_size:
                body.extend(
                    list(b"\x00" * (section.sizeof_raw_data - section.virtual_size)),
                )

            caves.extend(
                self._search_cave(
                    section.name,
                    body,
                    section_offset,
                    vaddr,
                ),
            )

        if caves:
            random_selected_cave = random.choice(caves)

            payload = self.extract_payload()

            bytez = bytearray(self.bytez)
            for index in range(min(random_selected_cave[-1], len(payload))):
                bytez[random_selected_cave[0] + index] = payload[index]
            self.bytez = bytes(bytez)

        return self.bytez

    def append_benign_data_overlay(self):

        payload = self.extract_payload()

        bytez = bytearray(self.bytez)
        for i in range(len(payload)):
            bytez.append(payload[i])

        self.bytez = bytes(bytez)

        return self.bytez

    def append_benign_data_pehead(self):

        payload = self.extract_payload()

        bytez = bytearray(self.bytez)

        for i in range(min(58, len(payload))):
            bytez[2 + i] = payload[i]
        self.bytez = bytes(bytez)

        return self.bytez

    def add_section_benign_data(self):
        # flag = False
        #
        # while flag == False:
        #     random_benign_file = self._randomly_select_trusted_file()
        #     pe = pefile.PE(random_benign_file)
        #     for section in pe.sections:
        #         if b'text' == section.Name[1:5]:
        #             flag = True
        #
        # benign_binary = lief.PE.parse(random_benign_file)
        # benign_binary_section_content = benign_binary.get_section(
        #         ".text",
        #     ).content

        payload = self.extract_payload()

        binary = lief.PE.parse(list(self.bytez))

        current_section_names = [section.name for section in binary.sections]
        available_section_names = list(
            set(ALL_SECTION_NAMES) - set(current_section_names),
        )

        if len(available_section_names) == 0:
            available_section_names = random.choice(string.ascii_lowercase)

        section = lief.PE.Section(random.choice(available_section_names))
        section.content = payload
        binary.add_section(section, lief.PE.SECTION_TYPES.DATA)

        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def rename_section(self, seed=None):
        # rename a random section
        random.seed(seed)
        binary = lief.PE.parse(list(self.bytez))

        # 所有section全部改名
        for targeted_section in binary.sections:
            targeted_section.name = random.choice(COMMON_SECTION_NAMES)[
                                    :7]  # current version of lief not allowing 8 chars?

        # 随机改一次名字
        # targeted_section = random.choice(binary.sections)
        # targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:7]  # current version of lief not allowing 8 chars?

        return self.bytez

    def add_imports(self):
        binary = lief.PE.parse(list(self.bytez))

        # draw a library at random
        libname = random.choice(list(COMMON_IMPORTS.keys()))
        funcname = random.choice(list(COMMON_IMPORTS[libname]))
        lowerlibname = libname.lower()

        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == lowerlibname:
                lib = im
                break

        if lib is None:
            # add a new library
            lib = binary.add_library(libname)

        # get current names
        names = {e.name for e in lib.entries}
        if funcname not in names:
            lib.add_entry(funcname)

        self.bytez = self._binary_to_bytez(binary, imports=True)

        return self.bytez


def modify_sample(bytez, action):
    bytez = ModifyBinary(bytez).__getattribute__(action)()
    return bytez


ACTION_TABLE = {
    "append_benign_data_overlay": "append_benign_data_overlay",
    "add_bytes_to_section_cave": "add_bytes_to_section_cave",
    "add_section_benign_data": "add_section_benign_data",
    "add_imports": "add_imports",
    "rename_section": "rename_section",
    "append_benign_data_pehead":"append_benign_data_pehead",
}

if __name__ == "__main__":
    # use for testing/debugging actions
    import hashlib

    from IPython import embed

    filename = "../utils/samples/fc29e40f62969a903520d1d5c66d1dc84c20f1724f36262fb1826cc4b548bddd"
    with open(filename, "rb") as f:
        bytez = f.read()

    m = hashlib.sha256()
    m.update(bytez)
    print(f"original hash: {m.hexdigest()}")

    action = "add_section_benign_data"
    m_bytez = modify_sample(bytez, action)

    m = hashlib.sha256()
    m.update(m_bytez)
    print(f"modified hash: {m.hexdigest()}")

    embed()
