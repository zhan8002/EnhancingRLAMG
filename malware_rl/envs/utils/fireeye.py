import os
import torch
import torch.nn as nn
import numpy as np
import sys

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
model_path = os.path.join(module_path, "fireeye_model.pth")

class FireEye(nn.Module):
    """
    DNN model from "Activation Analysis of a Byte-Based Deep Neural Network for Malware Classification" FireEye Inc.
    keep embed layer for training
    """
    def __init__(self, input_length=1048576, window_size=512,vocab_size=257):
        super(FireEye, self).__init__()

        self.padding_char = 256
        self.malicious_threshold = 0.5
        self.model = torch.load(model_path)

        self.maxlen = input_length

        self.embed = nn.Embedding(vocab_size, 10, padding_idx=256)

        self.conv_1 = nn.Conv1d(10, 16, 8, stride=4, bias=True)
        self.conv_2 = nn.Conv1d(16, 32, 16, stride=4, bias=True)
        self.conv_3 = nn.Conv1d(32, 64, 4, stride=2, bias=True)
        self.conv_4 = nn.Conv1d(64, 128, 4, stride=2, bias=True)
        self.conv_5 = nn.Conv1d(128, 128, 4, stride=2, bias=True)


        self.pooling = nn.MaxPool1d(int(input_length / window_size))
        # self.pooling = nn.AdaptiveMaxPool1d(1)

        # self.fc_1 = nn.Linear(128, 128)
        self.fc_2 = nn.Linear(128*3, 1)

        self.sigmoid = nn.Sigmoid() # binary classification
        # self.softmax = nn.Softmax()   # multi-classfication

    def forward(self, x):
        x = self.embed(x.long())
        # Channel first
        x = torch.transpose(x, -1, -2)

        x = self.conv_1(x)
        # x = self.pooling(x)
        x = self.conv_2(x)
        # x = self.pooling(x)
        x = self.conv_3(x)
        # x = self.pooling(x)
        x = self.conv_4(x)
        # x = self.pooling(x)
        x = self.conv_5(x)
        x = self.pooling(x)

        x = x.view(-1)
        x = self.fc_2(x)

        return x

    def extract(self, bytez):
        b = np.ones((self.maxlen,), dtype=np.int16) * self.padding_char
        bytez = np.frombuffer(bytez[: self.maxlen], dtype=np.uint8)
        b[: len(bytez)] = bytez
        return b
